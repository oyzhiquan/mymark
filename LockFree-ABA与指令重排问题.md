---
title: LockFree-ABA与指令重排问题
date: 2019-07-16 08:46:43
tags: C++
---

## ABA

在多线程编程中，最常拿来举例的问题便是著名的i++ 问题，即：多个线程对同一个共享变量i执行i++ 操作。这样做之所以会出现问题的原因在于i++这个操作可以分为三个步骤：

| step |          operation           |
| :--: | :--------------------------: |
|  1   |  i->reg(读取i的值到寄存器)   |
|  2   | inc-reg(在寄存器中自增i的值) |
|  3   |    reg->i (写回内存中的i)    |

上面三个步骤中间是可以间隔的，并非原子操作，也就是说多个线程同时执行的时候可能出步骤的交叉执行，例如下面的情况：

| step | thread A | thread B |
| :--: | :------: | :------: |
|  1   |  i->reg  |          |
|  2   | inc-reg  |          |
|  3   |          |  i->reg  |
|  4   |          | inc-reg  |
|  5   |  reg->i  |          |
|  6   |          |  reg->i  |

假设i一开始为0，则执行完第4步后，在两个线程都认为寄存器中的值为1，然后在第5、6两步分别写回去。最终两个线程执行完成后i的值为1。但是实际上我们在两个线程中执行了i++，原本希望i的值为2。i++ 实际上可以代表多线程编程中由于操作不是原子的而引发的交叉执行这一类的问题，但是在这里我们先只关注对单个变量的操作。

## 指令重排

有时候，我们会用一个变量作为标志位，当这个变量等于某个特定值的时候就进行某些操作。但是这样依然可能会有一些意想不到的坑，例如两个线程以如下顺序执行：

| step |  thread A  |    thread B    |
| :--: | :--------: | :------------: |
|  1   |   a = 1    |                |
|  2   | flag= true |                |
|  3   |            | if flag== true |
|  4   |            | assert(a == 1) |

当B判断flag为true后，断言a为1，看起来的确是这样。那么一定是这样吗？可能不是，因为编译器和CPU都可能将指令进行重排（编译器不同等级的优化和CPU的乱序执行）。实际上的执行顺序可能变成这样：

| step |  thread A   |    thread B    |
| :--: | :---------: | :------------: |
|  1   | flag = true |                |
|  2   |             | if flag== true |
|  3   |             | assert(a == 1) |
|  4   |    a = 1    |                |

这种重排有可能会导致一个线程内相互之间不存在依赖关系的指令交换执行顺序，以获得更高的执行效率。比如上面：flag 与 a 在A线程看起来是没有任何依赖关系，似乎执行顺序无关紧要。但问题在于B使用了flag作为是否读取a的依据，A的指令重排可能会导致step3的时候断言失败。

## 解决方案

一个比较稳妥的办法就是对于共享变量的访问进行加锁，加锁可以保证对临界区的互斥访问，例如第一种场景如果加锁后再执行i++ 然后解锁，则同一时刻只会有一个线程在执行i++ 操作。另外，加锁的内存语义能保证一个线程在释放锁前的写入操作一定能被之后加锁的线程所见（即有happens before 语义），可以避免第二种场景中读取到错误的值。

那么如果觉得加锁操作过重太麻烦而不想加锁呢？C++11提供了一些原子变量与原子操作来支持。